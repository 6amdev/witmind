# app/services/{{ENTITY}}.py
# Generated by WitMind.AI - Backend Dev Agent

from sqlalchemy import select, func, or_
from sqlalchemy.ext.asyncio import AsyncSession

from app.models.{{ENTITY}} import {{ENTITY_CLASS}}
from app.schemas.{{ENTITY}} import (
    {{ENTITY_CLASS}}Create,
    {{ENTITY_CLASS}}Update,
    {{ENTITY_CLASS}}Response,
    {{ENTITY_CLASS}}ListResponse,
    PaginationMeta,
)

# =============================================================================
# Service Class
# =============================================================================


class {{ENTITY_CLASS}}Service:
    """
    Service layer for {{ENTITY_CLASS}} operations.

    Handles business logic and orchestrates data access.
    """

    def __init__(self, db: AsyncSession):
        self.db = db

    # -------------------------------------------------------------------------
    # List
    # -------------------------------------------------------------------------

    async def list(
        self,
        user_id: str,
        page: int = 1,
        limit: int = 20,
        search: str | None = None,
        sort_by: str = "created_at",
        order: str = "desc",
    ) -> {{ENTITY_CLASS}}ListResponse:
        """
        Get paginated list of {{ENTITY_PLURAL}}.

        Args:
            user_id: Filter by owner
            page: Page number (1-indexed)
            limit: Items per page
            search: Search term for name/description
            sort_by: Field to sort by
            order: Sort order (asc/desc)

        Returns:
            Paginated list response
        """
        # Build base query
        query = select({{ENTITY_CLASS}}).where({{ENTITY_CLASS}}.user_id == user_id)

        # Apply search filter
        if search:
            search_filter = or_(
                {{ENTITY_CLASS}}.name.ilike(f"%{search}%"),
                {{ENTITY_CLASS}}.description.ilike(f"%{search}%"),
            )
            query = query.where(search_filter)

        # Count total
        count_query = select(func.count()).select_from(query.subquery())
        total = await self.db.scalar(count_query) or 0

        # Apply sorting
        sort_column = getattr({{ENTITY_CLASS}}, sort_by, {{ENTITY_CLASS}}.created_at)
        if order == "desc":
            query = query.order_by(sort_column.desc())
        else:
            query = query.order_by(sort_column.asc())

        # Apply pagination
        offset = (page - 1) * limit
        query = query.offset(offset).limit(limit)

        # Execute query
        result = await self.db.execute(query)
        items = result.scalars().all()

        # Build response
        return {{ENTITY_CLASS}}ListResponse(
            data=[{{ENTITY_CLASS}}Response.model_validate(item) for item in items],
            pagination=PaginationMeta(
                page=page,
                limit=limit,
                total=total,
                total_pages=(total + limit - 1) // limit,
            ),
        )

    # -------------------------------------------------------------------------
    # Get by ID
    # -------------------------------------------------------------------------

    async def get_by_id(
        self,
        {{ENTITY}}_id: str,
        user_id: str,
    ) -> {{ENTITY_CLASS}}Response | None:
        """
        Get a single {{ENTITY}} by ID.

        Args:
            {{ENTITY}}_id: {{ENTITY_CLASS}} ID
            user_id: Owner user ID (for authorization)

        Returns:
            {{ENTITY_CLASS}} response or None if not found
        """
        query = select({{ENTITY_CLASS}}).where(
            {{ENTITY_CLASS}}.id == {{ENTITY}}_id,
            {{ENTITY_CLASS}}.user_id == user_id,
        )
        result = await self.db.execute(query)
        item = result.scalar_one_or_none()

        if not item:
            return None

        return {{ENTITY_CLASS}}Response.model_validate(item)

    # -------------------------------------------------------------------------
    # Create
    # -------------------------------------------------------------------------

    async def create(
        self,
        data: {{ENTITY_CLASS}}Create,
        user_id: str,
    ) -> {{ENTITY_CLASS}}Response:
        """
        Create a new {{ENTITY}}.

        Args:
            data: Creation data
            user_id: Owner user ID

        Returns:
            Created {{ENTITY}}
        """
        item = {{ENTITY_CLASS}}(
            **data.model_dump(),
            user_id=user_id,
        )
        self.db.add(item)
        await self.db.commit()
        await self.db.refresh(item)

        return {{ENTITY_CLASS}}Response.model_validate(item)

    # -------------------------------------------------------------------------
    # Update
    # -------------------------------------------------------------------------

    async def update(
        self,
        {{ENTITY}}_id: str,
        data: {{ENTITY_CLASS}}Update,
        user_id: str,
    ) -> {{ENTITY_CLASS}}Response | None:
        """
        Update an existing {{ENTITY}}.

        Args:
            {{ENTITY}}_id: {{ENTITY_CLASS}} ID
            data: Update data
            user_id: Owner user ID (for authorization)

        Returns:
            Updated {{ENTITY}} or None if not found
        """
        query = select({{ENTITY_CLASS}}).where(
            {{ENTITY_CLASS}}.id == {{ENTITY}}_id,
            {{ENTITY_CLASS}}.user_id == user_id,
        )
        result = await self.db.execute(query)
        item = result.scalar_one_or_none()

        if not item:
            return None

        # Update only provided fields
        update_data = data.model_dump(exclude_unset=True)
        for field, value in update_data.items():
            setattr(item, field, value)

        await self.db.commit()
        await self.db.refresh(item)

        return {{ENTITY_CLASS}}Response.model_validate(item)

    # -------------------------------------------------------------------------
    # Delete
    # -------------------------------------------------------------------------

    async def delete(
        self,
        {{ENTITY}}_id: str,
        user_id: str,
    ) -> bool:
        """
        Delete a {{ENTITY}}.

        Args:
            {{ENTITY}}_id: {{ENTITY_CLASS}} ID
            user_id: Owner user ID (for authorization)

        Returns:
            True if deleted, False if not found
        """
        query = select({{ENTITY_CLASS}}).where(
            {{ENTITY_CLASS}}.id == {{ENTITY}}_id,
            {{ENTITY_CLASS}}.user_id == user_id,
        )
        result = await self.db.execute(query)
        item = result.scalar_one_or_none()

        if not item:
            return False

        await self.db.delete(item)
        await self.db.commit()

        return True
